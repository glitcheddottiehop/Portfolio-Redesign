import {
  __esm
} from "./chunk-CF3WPAMV.js";

// node_modules/@rehaps/rehaps-web-components/dist/esm/index-e9508d80.js
function queryNonceMetaTagContent(doc2) {
  var _a, _b, _c;
  return (_c = (_b = (_a = doc2.head) === null || _a === void 0 ? void 0 : _a.querySelector('meta[name="csp-nonce"]')) === null || _b === void 0 ? void 0 : _b.getAttribute("content")) !== null && _c !== void 0 ? _c : void 0;
}
var NAMESPACE, scopeId, hostTagName, isSvgMode, queuePending, getAssetPath, createTime, uniqueTime, CONTENT_REF_ID, ORG_LOCATION_ID, SLOT_NODE_ID, TEXT_NODE_ID, HYDRATE_ID, HYDRATED_STYLE_ID, HYDRATE_CHILD_ID, HYDRATED_CSS, EMPTY_OBJ, isDef, isComplexType, h, newVNode, Host, isHost, vdomFnUtils, convertToPublic, convertToPrivate, initializeClientHydrate, clientHydrate, initializeDocumentHydrate, parsePropertyValue, getElement, createEvent, emitEvent, rootAppliedStyles, registerStyle, addStyle, attachStyles, getScopeId, convertScopedToShadow, setAccessor, parseClassListRegex, parseClassList, updateElement, createElm, addVnodes, removeVnodes, updateChildren, isSameVnode, patch, nullifyVNodeRefs, renderVdom, attachToAncestor, scheduleUpdate, dispatchHooks, enqueue, isPromisey, updateComponent, callRender, postUpdateComponent, appDidLoad, safeCall, addHydratedFlag, getValue, setValue, proxyComponent, initializeComponent, fireConnectedCallback, connectedCallback, disconnectInstance, disconnectedCallback, patchCloneNode, patchSlotAppendChild, patchChildSlotNodes, getSlotName, getHostSlotNode, getHostSlotChildNodes, bootstrapLazy, Fragment, addHostEventListeners, hostListenerProxy, getHostListenerTarget, hostListenerOpts, setNonce, hostRefs, getHostRef, registerInstance, registerHost, isMemberInElement, consoleError, cmpModules, loadModule, styles, win, doc, H, plt, supportsShadow, promiseResolve, supportsConstructableStylesheets, queueDomReads, queueDomWrites, queueTask, consume, flush, nextTick, writeTask;
var init_index_e9508d80 = __esm({
  "node_modules/@rehaps/rehaps-web-components/dist/esm/index-e9508d80.js"() {
    NAMESPACE = "rehaps-web-components";
    isSvgMode = false;
    queuePending = false;
    getAssetPath = (path) => {
      const assetUrl = new URL(path, plt.$resourcesUrl$);
      return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;
    };
    createTime = (fnName, tagName = "") => {
      {
        return () => {
          return;
        };
      }
    };
    uniqueTime = (key, measureText) => {
      {
        return () => {
          return;
        };
      }
    };
    CONTENT_REF_ID = "r";
    ORG_LOCATION_ID = "o";
    SLOT_NODE_ID = "s";
    TEXT_NODE_ID = "t";
    HYDRATE_ID = "s-id";
    HYDRATED_STYLE_ID = "sty-id";
    HYDRATE_CHILD_ID = "c-id";
    HYDRATED_CSS = "{visibility:hidden}.hydrated{visibility:inherit}";
    EMPTY_OBJ = {};
    isDef = (v) => v != null;
    isComplexType = (o) => {
      o = typeof o;
      return o === "object" || o === "function";
    };
    h = (nodeName, vnodeData, ...children) => {
      let child = null;
      let key = null;
      let simple = false;
      let lastSimple = false;
      const vNodeChildren = [];
      const walk = (c) => {
        for (let i = 0; i < c.length; i++) {
          child = c[i];
          if (Array.isArray(child)) {
            walk(child);
          } else if (child != null && typeof child !== "boolean") {
            if (simple = typeof nodeName !== "function" && !isComplexType(child)) {
              child = String(child);
            }
            if (simple && lastSimple) {
              vNodeChildren[vNodeChildren.length - 1].$text$ += child;
            } else {
              vNodeChildren.push(simple ? newVNode(null, child) : child);
            }
            lastSimple = simple;
          }
        }
      };
      walk(children);
      if (vnodeData) {
        if (vnodeData.key) {
          key = vnodeData.key;
        }
        {
          const classData = vnodeData.className || vnodeData.class;
          if (classData) {
            vnodeData.class = typeof classData !== "object" ? classData : Object.keys(classData).filter((k) => classData[k]).join(" ");
          }
        }
      }
      if (typeof nodeName === "function") {
        return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);
      }
      const vnode = newVNode(nodeName, null);
      vnode.$attrs$ = vnodeData;
      if (vNodeChildren.length > 0) {
        vnode.$children$ = vNodeChildren;
      }
      {
        vnode.$key$ = key;
      }
      return vnode;
    };
    newVNode = (tag, text) => {
      const vnode = {
        $flags$: 0,
        $tag$: tag,
        $text$: text,
        $elm$: null,
        $children$: null
      };
      {
        vnode.$attrs$ = null;
      }
      {
        vnode.$key$ = null;
      }
      return vnode;
    };
    Host = {};
    isHost = (node) => node && node.$tag$ === Host;
    vdomFnUtils = {
      forEach: (children, cb) => children.map(convertToPublic).forEach(cb),
      map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate)
    };
    convertToPublic = (node) => ({
      vattrs: node.$attrs$,
      vchildren: node.$children$,
      vkey: node.$key$,
      vname: node.$name$,
      vtag: node.$tag$,
      vtext: node.$text$
    });
    convertToPrivate = (node) => {
      if (typeof node.vtag === "function") {
        const vnodeData = Object.assign({}, node.vattrs);
        if (node.vkey) {
          vnodeData.key = node.vkey;
        }
        if (node.vname) {
          vnodeData.name = node.vname;
        }
        return h(node.vtag, vnodeData, ...node.vchildren || []);
      }
      const vnode = newVNode(node.vtag, node.vtext);
      vnode.$attrs$ = node.vattrs;
      vnode.$children$ = node.vchildren;
      vnode.$key$ = node.vkey;
      vnode.$name$ = node.vname;
      return vnode;
    };
    initializeClientHydrate = (hostElm, tagName, hostId, hostRef) => {
      const endHydrate = createTime("hydrateClient", tagName);
      const shadowRoot = hostElm.shadowRoot;
      const childRenderNodes = [];
      const slotNodes = [];
      const shadowRootNodes = shadowRoot ? [] : null;
      const vnode = hostRef.$vnode$ = newVNode(tagName, null);
      if (!plt.$orgLocNodes$) {
        initializeDocumentHydrate(doc.body, plt.$orgLocNodes$ = /* @__PURE__ */ new Map());
      }
      hostElm[HYDRATE_ID] = hostId;
      hostElm.removeAttribute(HYDRATE_ID);
      clientHydrate(vnode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, hostElm, hostId);
      childRenderNodes.map((c) => {
        const orgLocationId = c.$hostId$ + "." + c.$nodeId$;
        const orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);
        const node = c.$elm$;
        if (orgLocationNode && supportsShadow && orgLocationNode["s-en"] === "") {
          orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);
        }
        if (!shadowRoot) {
          node["s-hn"] = tagName;
          if (orgLocationNode) {
            node["s-ol"] = orgLocationNode;
            node["s-ol"]["s-nr"] = node;
          }
        }
        plt.$orgLocNodes$.delete(orgLocationId);
      });
      if (shadowRoot) {
        shadowRootNodes.map((shadowRootNode) => {
          if (shadowRootNode) {
            shadowRoot.appendChild(shadowRootNode);
          }
        });
      }
      endHydrate();
    };
    clientHydrate = (parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId) => {
      let childNodeType;
      let childIdSplt;
      let childVNode;
      let i;
      if (node.nodeType === 1) {
        childNodeType = node.getAttribute(HYDRATE_CHILD_ID);
        if (childNodeType) {
          childIdSplt = childNodeType.split(".");
          if (childIdSplt[0] === hostId || childIdSplt[0] === "0") {
            childVNode = {
              $flags$: 0,
              $hostId$: childIdSplt[0],
              $nodeId$: childIdSplt[1],
              $depth$: childIdSplt[2],
              $index$: childIdSplt[3],
              $tag$: node.tagName.toLowerCase(),
              $elm$: node,
              $attrs$: null,
              $children$: null,
              $key$: null,
              $name$: null,
              $text$: null
            };
            childRenderNodes.push(childVNode);
            node.removeAttribute(HYDRATE_CHILD_ID);
            if (!parentVNode.$children$) {
              parentVNode.$children$ = [];
            }
            parentVNode.$children$[childVNode.$index$] = childVNode;
            parentVNode = childVNode;
            if (shadowRootNodes && childVNode.$depth$ === "0") {
              shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
            }
          }
        }
        for (i = node.childNodes.length - 1; i >= 0; i--) {
          clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.childNodes[i], hostId);
        }
        if (node.shadowRoot) {
          for (i = node.shadowRoot.childNodes.length - 1; i >= 0; i--) {
            clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.shadowRoot.childNodes[i], hostId);
          }
        }
      } else if (node.nodeType === 8) {
        childIdSplt = node.nodeValue.split(".");
        if (childIdSplt[1] === hostId || childIdSplt[1] === "0") {
          childNodeType = childIdSplt[0];
          childVNode = {
            $flags$: 0,
            $hostId$: childIdSplt[1],
            $nodeId$: childIdSplt[2],
            $depth$: childIdSplt[3],
            $index$: childIdSplt[4],
            $elm$: node,
            $attrs$: null,
            $children$: null,
            $key$: null,
            $name$: null,
            $tag$: null,
            $text$: null
          };
          if (childNodeType === TEXT_NODE_ID) {
            childVNode.$elm$ = node.nextSibling;
            if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3) {
              childVNode.$text$ = childVNode.$elm$.textContent;
              childRenderNodes.push(childVNode);
              node.remove();
              if (!parentVNode.$children$) {
                parentVNode.$children$ = [];
              }
              parentVNode.$children$[childVNode.$index$] = childVNode;
              if (shadowRootNodes && childVNode.$depth$ === "0") {
                shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
              }
            }
          } else if (childVNode.$hostId$ === hostId) {
            if (childNodeType === SLOT_NODE_ID) {
              childVNode.$tag$ = "slot";
              if (childIdSplt[5]) {
                node["s-sn"] = childVNode.$name$ = childIdSplt[5];
              } else {
                node["s-sn"] = "";
              }
              node["s-sr"] = true;
              if (shadowRootNodes) {
                childVNode.$elm$ = doc.createElement(childVNode.$tag$);
                if (childVNode.$name$) {
                  childVNode.$elm$.setAttribute("name", childVNode.$name$);
                }
                node.parentNode.insertBefore(childVNode.$elm$, node);
                node.remove();
                if (childVNode.$depth$ === "0") {
                  shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
                }
              }
              slotNodes.push(childVNode);
              if (!parentVNode.$children$) {
                parentVNode.$children$ = [];
              }
              parentVNode.$children$[childVNode.$index$] = childVNode;
            } else if (childNodeType === CONTENT_REF_ID) {
              if (shadowRootNodes) {
                node.remove();
              }
            }
          }
        }
      } else if (parentVNode && parentVNode.$tag$ === "style") {
        const vnode = newVNode(null, node.textContent);
        vnode.$elm$ = node;
        vnode.$index$ = "0";
        parentVNode.$children$ = [vnode];
      }
    };
    initializeDocumentHydrate = (node, orgLocNodes) => {
      if (node.nodeType === 1) {
        let i = 0;
        for (; i < node.childNodes.length; i++) {
          initializeDocumentHydrate(node.childNodes[i], orgLocNodes);
        }
        if (node.shadowRoot) {
          for (i = 0; i < node.shadowRoot.childNodes.length; i++) {
            initializeDocumentHydrate(node.shadowRoot.childNodes[i], orgLocNodes);
          }
        }
      } else if (node.nodeType === 8) {
        const childIdSplt = node.nodeValue.split(".");
        if (childIdSplt[0] === ORG_LOCATION_ID) {
          orgLocNodes.set(childIdSplt[1] + "." + childIdSplt[2], node);
          node.nodeValue = "";
          node["s-en"] = childIdSplt[3];
        }
      }
    };
    parsePropertyValue = (propValue, propType) => {
      if (propValue != null && !isComplexType(propValue)) {
        if (propType & 4) {
          return propValue === "false" ? false : propValue === "" || !!propValue;
        }
        if (propType & 2) {
          return parseFloat(propValue);
        }
        if (propType & 1) {
          return String(propValue);
        }
        return propValue;
      }
      return propValue;
    };
    getElement = (ref) => getHostRef(ref).$hostElement$;
    createEvent = (ref, name, flags) => {
      const elm = getElement(ref);
      return {
        emit: (detail) => {
          return emitEvent(elm, name, {
            bubbles: !!(flags & 4),
            composed: !!(flags & 2),
            cancelable: !!(flags & 1),
            detail
          });
        }
      };
    };
    emitEvent = (elm, name, opts) => {
      const ev = plt.ce(name, opts);
      elm.dispatchEvent(ev);
      return ev;
    };
    rootAppliedStyles = /* @__PURE__ */ new WeakMap();
    registerStyle = (scopeId2, cssText, allowCS) => {
      let style = styles.get(scopeId2);
      if (supportsConstructableStylesheets && allowCS) {
        style = style || new CSSStyleSheet();
        if (typeof style === "string") {
          style = cssText;
        } else {
          style.replaceSync(cssText);
        }
      } else {
        style = cssText;
      }
      styles.set(scopeId2, style);
    };
    addStyle = (styleContainerNode, cmpMeta, mode) => {
      var _a;
      const scopeId2 = getScopeId(cmpMeta);
      const style = styles.get(scopeId2);
      styleContainerNode = styleContainerNode.nodeType === 11 ? styleContainerNode : doc;
      if (style) {
        if (typeof style === "string") {
          styleContainerNode = styleContainerNode.head || styleContainerNode;
          let appliedStyles = rootAppliedStyles.get(styleContainerNode);
          let styleElm;
          if (!appliedStyles) {
            rootAppliedStyles.set(styleContainerNode, appliedStyles = /* @__PURE__ */ new Set());
          }
          if (!appliedStyles.has(scopeId2)) {
            if (styleContainerNode.host && (styleElm = styleContainerNode.querySelector(`[${HYDRATED_STYLE_ID}="${scopeId2}"]`))) {
              styleElm.innerHTML = style;
            } else {
              styleElm = doc.createElement("style");
              styleElm.innerHTML = style;
              const nonce = (_a = plt.$nonce$) !== null && _a !== void 0 ? _a : queryNonceMetaTagContent(doc);
              if (nonce != null) {
                styleElm.setAttribute("nonce", nonce);
              }
              styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector("link"));
            }
            if (appliedStyles) {
              appliedStyles.add(scopeId2);
            }
          }
        } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {
          styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];
        }
      }
      return scopeId2;
    };
    attachStyles = (hostRef) => {
      const cmpMeta = hostRef.$cmpMeta$;
      const elm = hostRef.$hostElement$;
      const flags = cmpMeta.$flags$;
      const endAttachStyles = createTime("attachStyles", cmpMeta.$tagName$);
      const scopeId2 = addStyle(elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta);
      if (flags & 10) {
        elm["s-sc"] = scopeId2;
        elm.classList.add(scopeId2 + "-h");
      }
      endAttachStyles();
    };
    getScopeId = (cmp, mode) => "sc-" + cmp.$tagName$;
    convertScopedToShadow = (css) => css.replace(/\/\*!@([^\/]+)\*\/[^\{]+\{/g, "$1{");
    setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {
      if (oldValue !== newValue) {
        let isProp = isMemberInElement(elm, memberName);
        let ln = memberName.toLowerCase();
        if (memberName === "class") {
          const classList = elm.classList;
          const oldClasses = parseClassList(oldValue);
          const newClasses = parseClassList(newValue);
          classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));
          classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));
        } else if (memberName === "style") {
          {
            for (const prop in oldValue) {
              if (!newValue || newValue[prop] == null) {
                if (prop.includes("-")) {
                  elm.style.removeProperty(prop);
                } else {
                  elm.style[prop] = "";
                }
              }
            }
          }
          for (const prop in newValue) {
            if (!oldValue || newValue[prop] !== oldValue[prop]) {
              if (prop.includes("-")) {
                elm.style.setProperty(prop, newValue[prop]);
              } else {
                elm.style[prop] = newValue[prop];
              }
            }
          }
        } else if (memberName === "key")
          ;
        else if (memberName === "ref") {
          if (newValue) {
            newValue(elm);
          }
        } else if (!isProp && memberName[0] === "o" && memberName[1] === "n") {
          if (memberName[2] === "-") {
            memberName = memberName.slice(3);
          } else if (isMemberInElement(win, ln)) {
            memberName = ln.slice(2);
          } else {
            memberName = ln[2] + memberName.slice(3);
          }
          if (oldValue) {
            plt.rel(elm, memberName, oldValue, false);
          }
          if (newValue) {
            plt.ael(elm, memberName, newValue, false);
          }
        } else {
          const isComplex = isComplexType(newValue);
          if ((isProp || isComplex && newValue !== null) && !isSvg) {
            try {
              if (!elm.tagName.includes("-")) {
                const n = newValue == null ? "" : newValue;
                if (memberName === "list") {
                  isProp = false;
                } else if (oldValue == null || elm[memberName] != n) {
                  elm[memberName] = n;
                }
              } else {
                elm[memberName] = newValue;
              }
            } catch (e) {
            }
          }
          if (newValue == null || newValue === false) {
            if (newValue !== false || elm.getAttribute(memberName) === "") {
              {
                elm.removeAttribute(memberName);
              }
            }
          } else if ((!isProp || flags & 4 || isSvg) && !isComplex) {
            newValue = newValue === true ? "" : newValue;
            {
              elm.setAttribute(memberName, newValue);
            }
          }
        }
      }
    };
    parseClassListRegex = /\s/;
    parseClassList = (value) => !value ? [] : value.split(parseClassListRegex);
    updateElement = (oldVnode, newVnode, isSvgMode2, memberName) => {
      const elm = newVnode.$elm$.nodeType === 11 && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
      const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;
      const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
      {
        for (memberName in oldVnodeAttrs) {
          if (!(memberName in newVnodeAttrs)) {
            setAccessor(elm, memberName, oldVnodeAttrs[memberName], void 0, isSvgMode2, newVnode.$flags$);
          }
        }
      }
      for (memberName in newVnodeAttrs) {
        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode2, newVnode.$flags$);
      }
    };
    createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {
      const newVNode2 = newParentVNode.$children$[childIndex];
      let i = 0;
      let elm;
      let childNode;
      if (newVNode2.$text$ !== null) {
        elm = newVNode2.$elm$ = doc.createTextNode(newVNode2.$text$);
      } else {
        elm = newVNode2.$elm$ = doc.createElement(newVNode2.$tag$);
        {
          updateElement(null, newVNode2, isSvgMode);
        }
        if (isDef(scopeId) && elm["s-si"] !== scopeId) {
          elm.classList.add(elm["s-si"] = scopeId);
        }
        if (newVNode2.$children$) {
          for (i = 0; i < newVNode2.$children$.length; ++i) {
            childNode = createElm(oldParentVNode, newVNode2, i);
            if (childNode) {
              elm.appendChild(childNode);
            }
          }
        }
      }
      return elm;
    };
    addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
      let containerElm = parentElm;
      let childNode;
      if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
        containerElm = containerElm.shadowRoot;
      }
      for (; startIdx <= endIdx; ++startIdx) {
        if (vnodes[startIdx]) {
          childNode = createElm(null, parentVNode, startIdx);
          if (childNode) {
            vnodes[startIdx].$elm$ = childNode;
            containerElm.insertBefore(childNode, before);
          }
        }
      }
    };
    removeVnodes = (vnodes, startIdx, endIdx) => {
      for (let index = startIdx; index <= endIdx; ++index) {
        const vnode = vnodes[index];
        if (vnode) {
          const elm = vnode.$elm$;
          nullifyVNodeRefs(vnode);
          if (elm) {
            elm.remove();
          }
        }
      }
    };
    updateChildren = (parentElm, oldCh, newVNode2, newCh) => {
      let oldStartIdx = 0;
      let newStartIdx = 0;
      let idxInOld = 0;
      let i = 0;
      let oldEndIdx = oldCh.length - 1;
      let oldStartVnode = oldCh[0];
      let oldEndVnode = oldCh[oldEndIdx];
      let newEndIdx = newCh.length - 1;
      let newStartVnode = newCh[0];
      let newEndVnode = newCh[newEndIdx];
      let node;
      let elmToMove;
      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (oldStartVnode == null) {
          oldStartVnode = oldCh[++oldStartIdx];
        } else if (oldEndVnode == null) {
          oldEndVnode = oldCh[--oldEndIdx];
        } else if (newStartVnode == null) {
          newStartVnode = newCh[++newStartIdx];
        } else if (newEndVnode == null) {
          newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldStartVnode, newStartVnode)) {
          patch(oldStartVnode, newStartVnode);
          oldStartVnode = oldCh[++oldStartIdx];
          newStartVnode = newCh[++newStartIdx];
        } else if (isSameVnode(oldEndVnode, newEndVnode)) {
          patch(oldEndVnode, newEndVnode);
          oldEndVnode = oldCh[--oldEndIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldStartVnode, newEndVnode)) {
          patch(oldStartVnode, newEndVnode);
          parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
          oldStartVnode = oldCh[++oldStartIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldEndVnode, newStartVnode)) {
          patch(oldEndVnode, newStartVnode);
          parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
          oldEndVnode = oldCh[--oldEndIdx];
          newStartVnode = newCh[++newStartIdx];
        } else {
          idxInOld = -1;
          {
            for (i = oldStartIdx; i <= oldEndIdx; ++i) {
              if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {
                idxInOld = i;
                break;
              }
            }
          }
          if (idxInOld >= 0) {
            elmToMove = oldCh[idxInOld];
            if (elmToMove.$tag$ !== newStartVnode.$tag$) {
              node = createElm(oldCh && oldCh[newStartIdx], newVNode2, idxInOld);
            } else {
              patch(elmToMove, newStartVnode);
              oldCh[idxInOld] = void 0;
              node = elmToMove.$elm$;
            }
            newStartVnode = newCh[++newStartIdx];
          } else {
            node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx);
            newStartVnode = newCh[++newStartIdx];
          }
          if (node) {
            {
              oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);
            }
          }
        }
      }
      if (oldStartIdx > oldEndIdx) {
        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode2, newCh, newStartIdx, newEndIdx);
      } else if (newStartIdx > newEndIdx) {
        removeVnodes(oldCh, oldStartIdx, oldEndIdx);
      }
    };
    isSameVnode = (leftVNode, rightVNode) => {
      if (leftVNode.$tag$ === rightVNode.$tag$) {
        {
          return leftVNode.$key$ === rightVNode.$key$;
        }
      }
      return false;
    };
    patch = (oldVNode, newVNode2) => {
      const elm = newVNode2.$elm$ = oldVNode.$elm$;
      const oldChildren = oldVNode.$children$;
      const newChildren = newVNode2.$children$;
      const tag = newVNode2.$tag$;
      const text = newVNode2.$text$;
      if (text === null) {
        {
          if (tag === "slot")
            ;
          else {
            updateElement(oldVNode, newVNode2, isSvgMode);
          }
        }
        if (oldChildren !== null && newChildren !== null) {
          updateChildren(elm, oldChildren, newVNode2, newChildren);
        } else if (newChildren !== null) {
          if (oldVNode.$text$ !== null) {
            elm.textContent = "";
          }
          addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);
        } else if (oldChildren !== null) {
          removeVnodes(oldChildren, 0, oldChildren.length - 1);
        }
      } else if (oldVNode.$text$ !== text) {
        elm.data = text;
      }
    };
    nullifyVNodeRefs = (vNode) => {
      {
        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
        vNode.$children$ && vNode.$children$.map(nullifyVNodeRefs);
      }
    };
    renderVdom = (hostRef, renderFnResults, isInitialLoad = false) => {
      const hostElm = hostRef.$hostElement$;
      const cmpMeta = hostRef.$cmpMeta$;
      const oldVNode = hostRef.$vnode$ || newVNode(null, null);
      const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);
      hostTagName = hostElm.tagName;
      if (cmpMeta.$attrsToReflect$) {
        rootVnode.$attrs$ = rootVnode.$attrs$ || {};
        cmpMeta.$attrsToReflect$.map(([propName, attribute]) => rootVnode.$attrs$[attribute] = hostElm[propName]);
      }
      if (isInitialLoad && rootVnode.$attrs$) {
        for (const key of Object.keys(rootVnode.$attrs$)) {
          if (hostElm.hasAttribute(key) && !["key", "ref", "style", "class"].includes(key)) {
            rootVnode.$attrs$[key] = hostElm[key];
          }
        }
      }
      rootVnode.$tag$ = null;
      rootVnode.$flags$ |= 4;
      hostRef.$vnode$ = rootVnode;
      rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;
      {
        scopeId = hostElm["s-sc"];
      }
      patch(oldVNode, rootVnode);
    };
    attachToAncestor = (hostRef, ancestorComponent) => {
      if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent["s-p"]) {
        ancestorComponent["s-p"].push(new Promise((r) => hostRef.$onRenderResolve$ = r));
      }
    };
    scheduleUpdate = (hostRef, isInitialLoad) => {
      {
        hostRef.$flags$ |= 16;
      }
      if (hostRef.$flags$ & 4) {
        hostRef.$flags$ |= 512;
        return;
      }
      attachToAncestor(hostRef, hostRef.$ancestorComponent$);
      const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
      return writeTask(dispatch);
    };
    dispatchHooks = (hostRef, isInitialLoad) => {
      const endSchedule = createTime("scheduleUpdate", hostRef.$cmpMeta$.$tagName$);
      const instance = hostRef.$lazyInstance$;
      let maybePromise;
      if (isInitialLoad) {
        {
          hostRef.$flags$ |= 256;
          if (hostRef.$queuedListeners$) {
            hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event));
            hostRef.$queuedListeners$ = void 0;
          }
        }
        {
          maybePromise = safeCall(instance, "componentWillLoad");
        }
      }
      {
        maybePromise = enqueue(maybePromise, () => safeCall(instance, "componentWillRender"));
      }
      endSchedule();
      return enqueue(maybePromise, () => updateComponent(hostRef, instance, isInitialLoad));
    };
    enqueue = (maybePromise, fn) => isPromisey(maybePromise) ? maybePromise.then(fn) : fn();
    isPromisey = (maybePromise) => maybePromise instanceof Promise || maybePromise && maybePromise.then && typeof maybePromise.then === "function";
    updateComponent = async (hostRef, instance, isInitialLoad) => {
      var _a;
      const elm = hostRef.$hostElement$;
      const endUpdate = createTime("update", hostRef.$cmpMeta$.$tagName$);
      const rc = elm["s-rc"];
      if (isInitialLoad) {
        attachStyles(hostRef);
      }
      const endRender = createTime("render", hostRef.$cmpMeta$.$tagName$);
      {
        callRender(hostRef, instance, elm, isInitialLoad);
      }
      if (rc) {
        rc.map((cb) => cb());
        elm["s-rc"] = void 0;
      }
      endRender();
      endUpdate();
      {
        const childrenPromises = (_a = elm["s-p"]) !== null && _a !== void 0 ? _a : [];
        const postUpdate = () => postUpdateComponent(hostRef);
        if (childrenPromises.length === 0) {
          postUpdate();
        } else {
          Promise.all(childrenPromises).then(postUpdate);
          hostRef.$flags$ |= 4;
          childrenPromises.length = 0;
        }
      }
    };
    callRender = (hostRef, instance, elm, isInitialLoad) => {
      try {
        instance = instance.render();
        {
          hostRef.$flags$ &= ~16;
        }
        {
          hostRef.$flags$ |= 2;
        }
        {
          {
            {
              renderVdom(hostRef, instance, isInitialLoad);
            }
          }
        }
      } catch (e) {
        consoleError(e, hostRef.$hostElement$);
      }
      return null;
    };
    postUpdateComponent = (hostRef) => {
      const tagName = hostRef.$cmpMeta$.$tagName$;
      const elm = hostRef.$hostElement$;
      const endPostUpdate = createTime("postUpdate", tagName);
      const instance = hostRef.$lazyInstance$;
      const ancestorComponent = hostRef.$ancestorComponent$;
      if (!(hostRef.$flags$ & 64)) {
        hostRef.$flags$ |= 64;
        {
          addHydratedFlag(elm);
        }
        {
          safeCall(instance, "componentDidLoad");
        }
        endPostUpdate();
        {
          hostRef.$onReadyResolve$(elm);
          if (!ancestorComponent) {
            appDidLoad();
          }
        }
      } else {
        endPostUpdate();
      }
      {
        hostRef.$onInstanceResolve$(elm);
      }
      {
        if (hostRef.$onRenderResolve$) {
          hostRef.$onRenderResolve$();
          hostRef.$onRenderResolve$ = void 0;
        }
        if (hostRef.$flags$ & 512) {
          nextTick(() => scheduleUpdate(hostRef, false));
        }
        hostRef.$flags$ &= ~(4 | 512);
      }
    };
    appDidLoad = (who) => {
      {
        addHydratedFlag(doc.documentElement);
      }
      nextTick(() => emitEvent(win, "appload", { detail: { namespace: NAMESPACE } }));
    };
    safeCall = (instance, method, arg) => {
      if (instance && instance[method]) {
        try {
          return instance[method](arg);
        } catch (e) {
          consoleError(e);
        }
      }
      return void 0;
    };
    addHydratedFlag = (elm) => elm.classList.add("hydrated");
    getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);
    setValue = (ref, propName, newVal, cmpMeta) => {
      const hostRef = getHostRef(ref);
      const elm = hostRef.$hostElement$;
      const oldVal = hostRef.$instanceValues$.get(propName);
      const flags = hostRef.$flags$;
      const instance = hostRef.$lazyInstance$;
      newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
      const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
      const didValueChange = newVal !== oldVal && !areBothNaN;
      if ((!(flags & 8) || oldVal === void 0) && didValueChange) {
        hostRef.$instanceValues$.set(propName, newVal);
        if (instance) {
          if (cmpMeta.$watchers$ && flags & 128) {
            const watchMethods = cmpMeta.$watchers$[propName];
            if (watchMethods) {
              watchMethods.map((watchMethodName) => {
                try {
                  instance[watchMethodName](newVal, oldVal, propName);
                } catch (e) {
                  consoleError(e, elm);
                }
              });
            }
          }
          if ((flags & (2 | 16)) === 2) {
            scheduleUpdate(hostRef, false);
          }
        }
      }
    };
    proxyComponent = (Cstr, cmpMeta, flags) => {
      if (cmpMeta.$members$) {
        if (Cstr.watchers) {
          cmpMeta.$watchers$ = Cstr.watchers;
        }
        const members = Object.entries(cmpMeta.$members$);
        const prototype = Cstr.prototype;
        members.map(([memberName, [memberFlags]]) => {
          if (memberFlags & 31 || flags & 2 && memberFlags & 32) {
            Object.defineProperty(prototype, memberName, {
              get() {
                return getValue(this, memberName);
              },
              set(newValue) {
                setValue(this, memberName, newValue, cmpMeta);
              },
              configurable: true,
              enumerable: true
            });
          } else if (flags & 1 && memberFlags & 64) {
            Object.defineProperty(prototype, memberName, {
              value(...args) {
                const ref = getHostRef(this);
                return ref.$onInstancePromise$.then(() => ref.$lazyInstance$[memberName](...args));
              }
            });
          }
        });
        if (flags & 1) {
          const attrNameToPropName = /* @__PURE__ */ new Map();
          prototype.attributeChangedCallback = function(attrName, _oldValue, newValue) {
            plt.jmp(() => {
              const propName = attrNameToPropName.get(attrName);
              if (this.hasOwnProperty(propName)) {
                newValue = this[propName];
                delete this[propName];
              } else if (prototype.hasOwnProperty(propName) && typeof this[propName] === "number" && this[propName] == newValue) {
                return;
              }
              this[propName] = newValue === null && typeof this[propName] === "boolean" ? false : newValue;
            });
          };
          Cstr.observedAttributes = members.filter(
            ([_, m]) => m[0] & 15
            /* MEMBER_FLAGS.HasAttribute */
          ).map(([propName, m]) => {
            const attrName = m[1] || propName;
            attrNameToPropName.set(attrName, propName);
            if (m[0] & 512) {
              cmpMeta.$attrsToReflect$.push([propName, attrName]);
            }
            return attrName;
          });
        }
      }
      return Cstr;
    };
    initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {
      if ((hostRef.$flags$ & 32) === 0) {
        hostRef.$flags$ |= 32;
        {
          Cstr = loadModule(cmpMeta);
          if (Cstr.then) {
            const endLoad = uniqueTime();
            Cstr = await Cstr;
            endLoad();
          }
          if (!Cstr.isProxied) {
            {
              cmpMeta.$watchers$ = Cstr.watchers;
            }
            proxyComponent(
              Cstr,
              cmpMeta,
              2
              /* PROXY_FLAGS.proxyState */
            );
            Cstr.isProxied = true;
          }
          const endNewInstance = createTime("createInstance", cmpMeta.$tagName$);
          {
            hostRef.$flags$ |= 8;
          }
          try {
            new Cstr(hostRef);
          } catch (e) {
            consoleError(e);
          }
          {
            hostRef.$flags$ &= ~8;
          }
          {
            hostRef.$flags$ |= 128;
          }
          endNewInstance();
          fireConnectedCallback(hostRef.$lazyInstance$);
        }
        if (Cstr.style) {
          let style = Cstr.style;
          const scopeId2 = getScopeId(cmpMeta);
          if (!styles.has(scopeId2)) {
            const endRegisterStyles = createTime("registerStyles", cmpMeta.$tagName$);
            registerStyle(scopeId2, style, !!(cmpMeta.$flags$ & 1));
            endRegisterStyles();
          }
        }
      }
      const ancestorComponent = hostRef.$ancestorComponent$;
      const schedule = () => scheduleUpdate(hostRef, true);
      if (ancestorComponent && ancestorComponent["s-rc"]) {
        ancestorComponent["s-rc"].push(schedule);
      } else {
        schedule();
      }
    };
    fireConnectedCallback = (instance) => {
      {
        safeCall(instance, "connectedCallback");
      }
    };
    connectedCallback = (elm) => {
      if ((plt.$flags$ & 1) === 0) {
        const hostRef = getHostRef(elm);
        const cmpMeta = hostRef.$cmpMeta$;
        const endConnected = createTime("connectedCallback", cmpMeta.$tagName$);
        if (!(hostRef.$flags$ & 1)) {
          hostRef.$flags$ |= 1;
          let hostId;
          {
            hostId = elm.getAttribute(HYDRATE_ID);
            if (hostId) {
              if (cmpMeta.$flags$ & 1) {
                const scopeId2 = addStyle(elm.shadowRoot, cmpMeta);
                elm.classList.remove(scopeId2 + "-h", scopeId2 + "-s");
              }
              initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);
            }
          }
          {
            let ancestorComponent = elm;
            while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {
              if (ancestorComponent.nodeType === 1 && ancestorComponent.hasAttribute("s-id") && ancestorComponent["s-p"] || ancestorComponent["s-p"]) {
                attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);
                break;
              }
            }
          }
          if (cmpMeta.$members$) {
            Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
              if (memberFlags & 31 && elm.hasOwnProperty(memberName)) {
                const value = elm[memberName];
                delete elm[memberName];
                elm[memberName] = value;
              }
            });
          }
          {
            initializeComponent(elm, hostRef, cmpMeta);
          }
        } else {
          addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
          if (hostRef === null || hostRef === void 0 ? void 0 : hostRef.$lazyInstance$) {
            fireConnectedCallback(hostRef.$lazyInstance$);
          } else if (hostRef === null || hostRef === void 0 ? void 0 : hostRef.$onReadyPromise$) {
            hostRef.$onReadyPromise$.then(() => fireConnectedCallback(hostRef.$lazyInstance$));
          }
        }
        endConnected();
      }
    };
    disconnectInstance = (instance) => {
      {
        safeCall(instance, "disconnectedCallback");
      }
    };
    disconnectedCallback = async (elm) => {
      if ((plt.$flags$ & 1) === 0) {
        const hostRef = getHostRef(elm);
        {
          if (hostRef.$rmListeners$) {
            hostRef.$rmListeners$.map((rmListener) => rmListener());
            hostRef.$rmListeners$ = void 0;
          }
        }
        if (hostRef === null || hostRef === void 0 ? void 0 : hostRef.$lazyInstance$) {
          disconnectInstance(hostRef.$lazyInstance$);
        } else if (hostRef === null || hostRef === void 0 ? void 0 : hostRef.$onReadyPromise$) {
          hostRef.$onReadyPromise$.then(() => disconnectInstance(hostRef.$lazyInstance$));
        }
      }
    };
    patchCloneNode = (HostElementPrototype) => {
      const orgCloneNode = HostElementPrototype.cloneNode;
      HostElementPrototype.cloneNode = function(deep) {
        const srcNode = this;
        const isShadowDom = srcNode.shadowRoot && supportsShadow;
        const clonedNode = orgCloneNode.call(srcNode, isShadowDom ? deep : false);
        if (!isShadowDom && deep) {
          let i = 0;
          let slotted, nonStencilNode;
          const stencilPrivates = [
            "s-id",
            "s-cr",
            "s-lr",
            "s-rc",
            "s-sc",
            "s-p",
            "s-cn",
            "s-sr",
            "s-sn",
            "s-hn",
            "s-ol",
            "s-nr",
            "s-si"
          ];
          for (; i < srcNode.childNodes.length; i++) {
            slotted = srcNode.childNodes[i]["s-nr"];
            nonStencilNode = stencilPrivates.every((privateField) => !srcNode.childNodes[i][privateField]);
            if (slotted) {
              if (clonedNode.__appendChild) {
                clonedNode.__appendChild(slotted.cloneNode(true));
              } else {
                clonedNode.appendChild(slotted.cloneNode(true));
              }
            }
            if (nonStencilNode) {
              clonedNode.appendChild(srcNode.childNodes[i].cloneNode(true));
            }
          }
        }
        return clonedNode;
      };
    };
    patchSlotAppendChild = (HostElementPrototype) => {
      HostElementPrototype.__appendChild = HostElementPrototype.appendChild;
      HostElementPrototype.appendChild = function(newChild) {
        const slotName = newChild["s-sn"] = getSlotName(newChild);
        const slotNode = getHostSlotNode(this.childNodes, slotName);
        if (slotNode) {
          const slotChildNodes = getHostSlotChildNodes(slotNode, slotName);
          const appendAfter = slotChildNodes[slotChildNodes.length - 1];
          return appendAfter.parentNode.insertBefore(newChild, appendAfter.nextSibling);
        }
        return this.__appendChild(newChild);
      };
    };
    patchChildSlotNodes = (elm, cmpMeta) => {
      class FakeNodeList extends Array {
        item(n) {
          return this[n];
        }
      }
      if (cmpMeta.$flags$ & 8) {
        const childNodesFn = elm.__lookupGetter__("childNodes");
        Object.defineProperty(elm, "children", {
          get() {
            return this.childNodes.map((n) => n.nodeType === 1);
          }
        });
        Object.defineProperty(elm, "childElementCount", {
          get() {
            return elm.children.length;
          }
        });
        Object.defineProperty(elm, "childNodes", {
          get() {
            const childNodes = childNodesFn.call(this);
            if ((plt.$flags$ & 1) === 0 && getHostRef(this).$flags$ & 2) {
              const result = new FakeNodeList();
              for (let i = 0; i < childNodes.length; i++) {
                const slot = childNodes[i]["s-nr"];
                if (slot) {
                  result.push(slot);
                }
              }
              return result;
            }
            return FakeNodeList.from(childNodes);
          }
        });
      }
    };
    getSlotName = (node) => node["s-sn"] || node.nodeType === 1 && node.getAttribute("slot") || "";
    getHostSlotNode = (childNodes, slotName) => {
      let i = 0;
      let childNode;
      for (; i < childNodes.length; i++) {
        childNode = childNodes[i];
        if (childNode["s-sr"] && childNode["s-sn"] === slotName) {
          return childNode;
        }
        childNode = getHostSlotNode(childNode.childNodes, slotName);
        if (childNode) {
          return childNode;
        }
      }
      return null;
    };
    getHostSlotChildNodes = (n, slotName) => {
      const childNodes = [n];
      while ((n = n.nextSibling) && n["s-sn"] === slotName) {
        childNodes.push(n);
      }
      return childNodes;
    };
    bootstrapLazy = (lazyBundles, options = {}) => {
      var _a;
      const endBootstrap = createTime();
      const cmpTags = [];
      const exclude = options.exclude || [];
      const customElements = win.customElements;
      const head = doc.head;
      const metaCharset = head.querySelector("meta[charset]");
      const visibilityStyle = doc.createElement("style");
      const deferredConnectedCallbacks = [];
      const styles2 = doc.querySelectorAll(`[${HYDRATED_STYLE_ID}]`);
      let appLoadFallback;
      let isBootstrapping = true;
      let i = 0;
      Object.assign(plt, options);
      plt.$resourcesUrl$ = new URL(options.resourcesUrl || "./", doc.baseURI).href;
      {
        plt.$flags$ |= 2;
      }
      {
        for (; i < styles2.length; i++) {
          registerStyle(styles2[i].getAttribute(HYDRATED_STYLE_ID), convertScopedToShadow(styles2[i].innerHTML), true);
        }
      }
      lazyBundles.map((lazyBundle) => {
        lazyBundle[1].map((compactMeta) => {
          const cmpMeta = {
            $flags$: compactMeta[0],
            $tagName$: compactMeta[1],
            $members$: compactMeta[2],
            $listeners$: compactMeta[3]
          };
          {
            cmpMeta.$members$ = compactMeta[2];
          }
          {
            cmpMeta.$listeners$ = compactMeta[3];
          }
          {
            cmpMeta.$attrsToReflect$ = [];
          }
          {
            cmpMeta.$watchers$ = {};
          }
          const tagName = cmpMeta.$tagName$;
          const HostElement = class extends HTMLElement {
            // StencilLazyHost
            constructor(self) {
              super(self);
              self = this;
              registerHost(self, cmpMeta);
              if (cmpMeta.$flags$ & 1) {
                {
                  {
                    self.attachShadow({ mode: "open" });
                  }
                }
              }
            }
            connectedCallback() {
              if (appLoadFallback) {
                clearTimeout(appLoadFallback);
                appLoadFallback = null;
              }
              if (isBootstrapping) {
                deferredConnectedCallbacks.push(this);
              } else {
                plt.jmp(() => connectedCallback(this));
              }
            }
            disconnectedCallback() {
              plt.jmp(() => disconnectedCallback(this));
            }
            componentOnReady() {
              return getHostRef(this).$onReadyPromise$;
            }
          };
          {
            {
              patchChildSlotNodes(HostElement.prototype, cmpMeta);
            }
            {
              patchCloneNode(HostElement.prototype);
            }
            {
              patchSlotAppendChild(HostElement.prototype);
            }
          }
          cmpMeta.$lazyBundleId$ = lazyBundle[0];
          if (!exclude.includes(tagName) && !customElements.get(tagName)) {
            cmpTags.push(tagName);
            customElements.define(tagName, proxyComponent(
              HostElement,
              cmpMeta,
              1
              /* PROXY_FLAGS.isElementConstructor */
            ));
          }
        });
      });
      {
        visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;
        visibilityStyle.setAttribute("data-styles", "");
        const nonce = (_a = plt.$nonce$) !== null && _a !== void 0 ? _a : queryNonceMetaTagContent(doc);
        if (nonce != null) {
          visibilityStyle.setAttribute("nonce", nonce);
        }
        head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);
      }
      isBootstrapping = false;
      if (deferredConnectedCallbacks.length) {
        deferredConnectedCallbacks.map((host) => host.connectedCallback());
      } else {
        {
          plt.jmp(() => appLoadFallback = setTimeout(appDidLoad, 30));
        }
      }
      endBootstrap();
    };
    Fragment = (_, children) => children;
    addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {
      if (listeners) {
        listeners.map(([flags, name, method]) => {
          const target = getHostListenerTarget(elm, flags);
          const handler = hostListenerProxy(hostRef, method);
          const opts = hostListenerOpts(flags);
          plt.ael(target, name, handler, opts);
          (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));
        });
      }
    };
    hostListenerProxy = (hostRef, methodName) => (ev) => {
      try {
        {
          if (hostRef.$flags$ & 256) {
            hostRef.$lazyInstance$[methodName](ev);
          } else {
            (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);
          }
        }
      } catch (e) {
        consoleError(e);
      }
    };
    getHostListenerTarget = (elm, flags) => {
      if (flags & 4)
        return doc;
      if (flags & 8)
        return win;
      return elm;
    };
    hostListenerOpts = (flags) => (flags & 2) !== 0;
    setNonce = (nonce) => plt.$nonce$ = nonce;
    hostRefs = /* @__PURE__ */ new WeakMap();
    getHostRef = (ref) => hostRefs.get(ref);
    registerInstance = (lazyInstance, hostRef) => hostRefs.set(hostRef.$lazyInstance$ = lazyInstance, hostRef);
    registerHost = (elm, cmpMeta) => {
      const hostRef = {
        $flags$: 0,
        $hostElement$: elm,
        $cmpMeta$: cmpMeta,
        $instanceValues$: /* @__PURE__ */ new Map()
      };
      {
        hostRef.$onInstancePromise$ = new Promise((r) => hostRef.$onInstanceResolve$ = r);
      }
      {
        hostRef.$onReadyPromise$ = new Promise((r) => hostRef.$onReadyResolve$ = r);
        elm["s-p"] = [];
        elm["s-rc"] = [];
      }
      addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
      return hostRefs.set(elm, hostRef);
    };
    isMemberInElement = (elm, memberName) => memberName in elm;
    consoleError = (e, el) => (0, console.error)(e, el);
    cmpModules = /* @__PURE__ */ new Map();
    loadModule = (cmpMeta, hostRef, hmrVersionId) => {
      const exportName = cmpMeta.$tagName$.replace(/-/g, "_");
      const bundleId = cmpMeta.$lazyBundleId$;
      const module = cmpModules.get(bundleId);
      if (module) {
        return module[exportName];
      }
      if (!hmrVersionId || !BUILD.hotModuleReplacement) {
        const processMod = (importedModule) => {
          cmpModules.set(bundleId, importedModule);
          return importedModule[exportName];
        };
        switch (bundleId) {
          case "rwc-tabs":
            return import(
              /* webpackMode: "lazy" */
              "./rwc-tabs.entry-QCDAZR4U.js"
            ).then(processMod, consoleError);
          case "rwc-auto-layout":
            return import(
              /* webpackMode: "lazy" */
              "./rwc-auto-layout.entry-QWVVZGOL.js"
            ).then(processMod, consoleError);
          case "rwc-button":
            return import(
              /* webpackMode: "lazy" */
              "./rwc-button.entry-LC532SRB.js"
            ).then(processMod, consoleError);
          case "rwc-container":
            return import(
              /* webpackMode: "lazy" */
              "./rwc-container.entry-PHQCJVUL.js"
            ).then(processMod, consoleError);
          case "rwc-folding-squares":
            return import(
              /* webpackMode: "lazy" */
              "./rwc-folding-squares.entry-FN5GCNYG.js"
            ).then(processMod, consoleError);
          case "rwc-hero-banner":
            return import(
              /* webpackMode: "lazy" */
              "./rwc-hero-banner.entry-T2IF36NX.js"
            ).then(processMod, consoleError);
          case "rwc-icon-text-steps":
            return import(
              /* webpackMode: "lazy" */
              "./rwc-icon-text-steps.entry-4QQ6TS7E.js"
            ).then(processMod, consoleError);
          case "rwc-info-card":
            return import(
              /* webpackMode: "lazy" */
              "./rwc-info-card.entry-FU2MA4QN.js"
            ).then(processMod, consoleError);
          case "rwc-input":
            return import(
              /* webpackMode: "lazy" */
              "./rwc-input.entry-2UARIJD2.js"
            ).then(processMod, consoleError);
          case "rwc-modal":
            return import(
              /* webpackMode: "lazy" */
              "./rwc-modal.entry-PO224QI6.js"
            ).then(processMod, consoleError);
          case "rwc-navigation-element":
            return import(
              /* webpackMode: "lazy" */
              "./rwc-navigation-element.entry-W2UJHTAZ.js"
            ).then(processMod, consoleError);
          case "rwc-post-card":
            return import(
              /* webpackMode: "lazy" */
              "./rwc-post-card.entry-D3Z6J6EO.js"
            ).then(processMod, consoleError);
          case "rwc-select":
            return import(
              /* webpackMode: "lazy" */
              "./rwc-select.entry-6A5DJYA7.js"
            ).then(processMod, consoleError);
          case "rwc-sidebar":
            return import(
              /* webpackMode: "lazy" */
              "./rwc-sidebar.entry-SD6BZF3V.js"
            ).then(processMod, consoleError);
          case "rwc-slides":
            return import(
              /* webpackMode: "lazy" */
              "./rwc-slides.entry-YCFGQXD4.js"
            ).then(processMod, consoleError);
          case "rwc-spinner":
            return import(
              /* webpackMode: "lazy" */
              "./rwc-spinner.entry-BHQ2SJDP.js"
            ).then(processMod, consoleError);
          case "rwc-system-notifications":
            return import(
              /* webpackMode: "lazy" */
              "./rwc-system-notifications.entry-SVI3TBR3.js"
            ).then(processMod, consoleError);
          case "rwc-tag":
            return import(
              /* webpackMode: "lazy" */
              "./rwc-tag.entry-RBQ5LJ5D.js"
            ).then(processMod, consoleError);
          case "rwc-user-card":
            return import(
              /* webpackMode: "lazy" */
              "./rwc-user-card.entry-27Y3EBJZ.js"
            ).then(processMod, consoleError);
          case "rwc-accordion_2":
            return import(
              /* webpackMode: "lazy" */
              "./rwc-accordion_2.entry-O4M2OTZQ.js"
            ).then(processMod, consoleError);
          case "rwc-grid":
            return import(
              /* webpackMode: "lazy" */
              "./rwc-grid.entry-ODQFFD32.js"
            ).then(processMod, consoleError);
          case "rwc-dropdown":
            return import(
              /* webpackMode: "lazy" */
              "./rwc-dropdown.entry-V25HPARW.js"
            ).then(processMod, consoleError);
          case "rwc-card":
            return import(
              /* webpackMode: "lazy" */
              "./rwc-card.entry-DKW6LQ3X.js"
            ).then(processMod, consoleError);
        }
      }
      return import(
        /* @vite-ignore */
        /* webpackInclude: /\.entry\.js$/ */
        /* webpackExclude: /\.system\.entry\.js$/ */
        /* webpackMode: "lazy" */
        `./${bundleId}.entry.js${""}`
      ).then((importedModule) => {
        {
          cmpModules.set(bundleId, importedModule);
        }
        return importedModule[exportName];
      }, consoleError);
    };
    styles = /* @__PURE__ */ new Map();
    win = typeof window !== "undefined" ? window : {};
    doc = win.document || { head: {} };
    H = win.HTMLElement || class {
    };
    plt = {
      $flags$: 0,
      $resourcesUrl$: "",
      jmp: (h2) => h2(),
      raf: (h2) => requestAnimationFrame(h2),
      ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),
      rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),
      ce: (eventName, opts) => new CustomEvent(eventName, opts)
    };
    supportsShadow = // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
    true;
    promiseResolve = (v) => Promise.resolve(v);
    supportsConstructableStylesheets = (() => {
      try {
        new CSSStyleSheet();
        return typeof new CSSStyleSheet().replaceSync === "function";
      } catch (e) {
      }
      return false;
    })();
    queueDomReads = [];
    queueDomWrites = [];
    queueTask = (queue, write) => (cb) => {
      queue.push(cb);
      if (!queuePending) {
        queuePending = true;
        if (write && plt.$flags$ & 4) {
          nextTick(flush);
        } else {
          plt.raf(flush);
        }
      }
    };
    consume = (queue) => {
      for (let i = 0; i < queue.length; i++) {
        try {
          queue[i](performance.now());
        } catch (e) {
          consoleError(e);
        }
      }
      queue.length = 0;
    };
    flush = () => {
      consume(queueDomReads);
      {
        consume(queueDomWrites);
        if (queuePending = queueDomReads.length > 0) {
          plt.raf(flush);
        }
      }
    };
    nextTick = (cb) => promiseResolve().then(cb);
    writeTask = queueTask(queueDomWrites, true);
  }
});

export {
  getAssetPath,
  h,
  Host,
  getElement,
  createEvent,
  bootstrapLazy,
  Fragment,
  setNonce,
  registerInstance,
  init_index_e9508d80
};
//# sourceMappingURL=chunk-6OFGPT5F.js.map
