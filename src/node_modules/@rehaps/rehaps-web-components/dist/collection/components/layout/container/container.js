import { h, Host } from "@stencil/core";
export class Container {
  constructor() {
    this.initialized = false;
    this.scrollIntoAnimation = undefined;
    this.scrollOutAnimation = undefined;
    this.animateOpacity = true;
    this.animationDuration = 300;
    this.visibilityThreshold = 0;
    this.isVisible = false;
  }
  onAnimationDurationChange(newValue) {
    this.setAnimationDuration(newValue);
  }
  componentWillLoad() {
    this.setAnimationDuration(this.animationDuration);
  }
  componentDidLoad() {
    this.initIntersectionObserver();
  }
  initIntersectionObserver() {
    this.intersectionObserver = new IntersectionObserver((entries) => this.handleIntersection(entries), { threshold: this.visibilityThreshold });
    this.intersectionObserver.observe(this.host);
  }
  handleIntersection(entries) {
    if (entries[0].isIntersecting) {
      this.isVisible = true;
      if (this.scrollOutAnimation === 'none' || !this.scrollOutAnimation) {
        this.removeIntersectionObserver();
      }
    }
    else {
      this.isVisible = false;
      if (this.scrollIntoAnimation === 'none' || !this.scrollIntoAnimation) {
        this.removeIntersectionObserver();
      }
    }
  }
  removeIntersectionObserver() {
    if (this.initialized && this.intersectionObserver || (!this.hasScrollIntoAnimation && !this.hasScrollOutAnimation && this.isVisible)) {
      this.intersectionObserver.disconnect();
      this.intersectionObserver = null;
    }
    this.initialized = true;
  }
  setAnimationDuration(duration) {
    this.host.style.setProperty('--_animation-duration', `${duration}ms`);
  }
  get hasScrollIntoAnimation() {
    return this.scrollIntoAnimation && this.scrollIntoAnimation !== 'none';
  }
  get hasScrollOutAnimation() {
    return this.scrollOutAnimation && this.scrollOutAnimation !== 'none';
  }
  render() {
    return (h(Host, null, h("div", { class: {
        wrapper: true,
        visible: this.isVisible,
        'animate-opacity': this.animateOpacity,
        [`scroll-in-${this.scrollIntoAnimation}`]: true,
        [`scroll-out-${this.scrollOutAnimation}`]: true,
      } }, h("div", { class: "container" }, h("slot", null)))));
  }
  static get is() { return "rwc-container"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["container.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["container.css"]
    };
  }
  static get properties() {
    return {
      "scrollIntoAnimation": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "ContainerAnimation",
          "resolved": "\"none\" | \"slide-bottom\" | \"slide-left\" | \"slide-right\" | \"slide-top\"",
          "references": {
            "ContainerAnimation": {
              "location": "import",
              "path": "../../../interfaces/components/layout/container/types",
              "id": "src/interfaces/components/layout/container/types.ts::ContainerAnimation"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "The animation to play when the container is scrolled into viewport"
        },
        "attribute": "scroll-into-animation",
        "reflect": false
      },
      "scrollOutAnimation": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "ContainerAnimation",
          "resolved": "\"none\" | \"slide-bottom\" | \"slide-left\" | \"slide-right\" | \"slide-top\"",
          "references": {
            "ContainerAnimation": {
              "location": "import",
              "path": "../../../interfaces/components/layout/container/types",
              "id": "src/interfaces/components/layout/container/types.ts::ContainerAnimation"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "The animation to play when the container is scrolled out of viewport"
        },
        "attribute": "scroll-out-animation",
        "reflect": false
      },
      "animateOpacity": {
        "type": "boolean",
        "mutable": false,
        "complexType": {
          "original": "boolean",
          "resolved": "boolean",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Enable the opacity animation for the scroll animation"
        },
        "attribute": "animate-opacity",
        "reflect": false,
        "defaultValue": "true"
      },
      "animationDuration": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "The duration of the animation in milliseconds"
        },
        "attribute": "animation-duration",
        "reflect": true,
        "defaultValue": "300"
      },
      "visibilityThreshold": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number",
          "references": {}
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "The intersection threshold for the animation to trigger \\\nWhat percentage of the element must be in the viewport to trigger the animation"
        },
        "attribute": "visibility-threshold",
        "reflect": false,
        "defaultValue": "0"
      }
    };
  }
  static get states() {
    return {
      "isVisible": {}
    };
  }
  static get elementRef() { return "host"; }
  static get watchers() {
    return [{
        "propName": "animationDuration",
        "methodName": "onAnimationDurationChange"
      }];
  }
}
//# sourceMappingURL=container.js.map
