import { h, Host, Fragment, } from "@stencil/core";
import CloseIcon from "@material-design-icons/svg/round/close.svg";
export class RwcSystemNotification {
  constructor() {
    this.notifications = new Map();
    this.stateChangeTrigger = false;
  }
  get animationDuration() {
    return Number.parseInt(getComputedStyle(this.host).getPropertyValue("--system-notifications-fade-animation-duration"));
  }
  get heightAnimationDuration() {
    return Number.parseInt(getComputedStyle(this.host).getPropertyValue("--system-notifications-height-animation-duration"));
  }
  onWindowResize() {
    this.notificationContainerElement
      .querySelectorAll(".notification-wrapper")
      .forEach((wrapper) => {
      wrapper.style.maxHeight = `${wrapper.scrollHeight}px`;
    });
  }
  connectedCallback() {
    this.notifications.clear();
  }
  disconnectedCallback() {
    this.notifications.forEach((timeout) => {
      clearTimeout(timeout);
    });
  }
  async pushNotification(notification) {
    if (!notification.key) {
      notification.key = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString();
    }
    this.notifications.set(notification, this.initAutoRemove(notification));
    if (this.forceStateChange()) {
      await new Promise(requestAnimationFrame);
      setTimeout(() => {
        this.updateNotificationMaxHeight(notification);
      }, 0);
    }
    return notification.key;
  }
  async setNotifications(notifications) {
    this.clearNotifications();
    const keys = [];
    for (const notification of notifications) {
      keys.push(await this.pushNotification(notification));
    }
    return keys;
  }
  async removeNotification(index) {
    const key = Array.from(this.notifications.keys())[index];
    this.removeNotificationByReference(key);
  }
  async clearNotifications() {
    this.notifications.clear();
    this.forceStateChange();
  }
  initAutoRemove(notification) {
    this.unsetAutoRemoveByReference(notification);
    if (notification.duration > 0) {
      return setTimeout(() => {
        this.removeNotificationByReference(notification);
      }, notification.duration);
    }
    return null;
  }
  unsetAutoRemoveByReference(notification) {
    const timeout = this.notifications.get(notification);
    if (timeout !== null) {
      clearTimeout(timeout);
    }
  }
  async removeNotificationByReference(notification) {
    setTimeout(() => {
      notification.closing = true;
      if (this.forceStateChange()) {
        setTimeout(() => {
          this.handleNotificationRemove(notification);
        }, Math.max(0, this.animationDuration - this.heightAnimationDuration));
      }
    }, 0);
  }
  async handleNotificationRemove(notification) {
    setTimeout(() => {
      this.notifications.delete(notification);
      this.forceStateChange();
    }, Math.max(0, this.heightAnimationDuration));
  }
  updateNotificationMaxHeight(notification) {
    const notificationElement = this.notificationContainerElement.querySelector(`[data-key="${notification.key}"]`);
    if (notificationElement) {
      notificationElement.style.maxHeight = `${notificationElement.scrollHeight}px`;
    }
    return notificationElement;
  }
  forceStateChange() {
    try {
      this.stateChangeTrigger = !this.stateChangeTrigger;
      return true;
    }
    catch (e) {
      return false;
    }
  }
  render() {
    return (h(Host, null, h("div", { ref: (element) => (this.notificationContainerElement = element), class: "container" }, this.renderNotifications())));
  }
  renderNotifications() {
    var _a;
    const notificationElements = [];
    for (const [notification, _timeout] of this.notifications) {
      notificationElements.push(h("div", { class: {
          ["notification-wrapper"]: true,
          closing: notification.closing,
        }, key: notification.key, "data-key": notification.key, onMouseEnter: () => this.unsetAutoRemoveByReference(notification), onMouseLeave: () => this.initAutoRemove(notification) }, h("div", { class: {
          notification: true,
          [(_a = notification.type) !== null && _a !== void 0 ? _a : "info"]: true,
        } }, this.renderCloseIcon(notification), notification.title && h("p", { class: "title" }, notification.title), notification.message && (h("p", { class: "message" }, notification.message)))));
    }
    return notificationElements;
  }
  renderCloseIcon(notification) {
    if (notification.closable) {
      return (h("div", { class: "close-icon", innerHTML: CloseIcon, onClick: () => this.removeNotificationByReference(notification) }));
    }
    return h(Fragment, null);
  }
  static get is() { return "rwc-system-notifications"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["system-notifications.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["system-notifications.css"]
    };
  }
  static get states() {
    return {
      "notifications": {},
      "stateChangeTrigger": {}
    };
  }
  static get methods() {
    return {
      "pushNotification": {
        "complexType": {
          "signature": "(notification: SystemNotificationInterface) => Promise<string>",
          "parameters": [{
              "tags": [],
              "text": ""
            }],
          "references": {
            "Promise": {
              "location": "global",
              "id": "global::Promise"
            },
            "SystemNotificationInterface": {
              "location": "import",
              "path": "../../../interfaces/components/messages/system-notifications/system-notifications",
              "id": "src/interfaces/components/messages/system-notifications/system-notifications.ts::SystemNotificationInterface"
            }
          },
          "return": "Promise<string>"
        },
        "docs": {
          "text": "This method pushes a notification. Generates random key if not set.",
          "tags": [{
              "name": "returns",
              "text": "The notification key."
            }]
        }
      },
      "setNotifications": {
        "complexType": {
          "signature": "(notifications: SystemNotificationInterface[]) => Promise<string[]>",
          "parameters": [{
              "tags": [],
              "text": ""
            }],
          "references": {
            "Promise": {
              "location": "global",
              "id": "global::Promise"
            },
            "SystemNotificationInterface": {
              "location": "import",
              "path": "../../../interfaces/components/messages/system-notifications/system-notifications",
              "id": "src/interfaces/components/messages/system-notifications/system-notifications.ts::SystemNotificationInterface"
            }
          },
          "return": "Promise<string[]>"
        },
        "docs": {
          "text": "This method sets notifications.",
          "tags": []
        }
      },
      "removeNotification": {
        "complexType": {
          "signature": "(index: number) => Promise<void>",
          "parameters": [{
              "tags": [],
              "text": ""
            }],
          "references": {
            "Promise": {
              "location": "global",
              "id": "global::Promise"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "This method removes a notification.",
          "tags": []
        }
      },
      "clearNotifications": {
        "complexType": {
          "signature": "() => Promise<void>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global",
              "id": "global::Promise"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "This method clears all notifications.",
          "tags": []
        }
      }
    };
  }
  static get elementRef() { return "host"; }
  static get listeners() {
    return [{
        "name": "resize",
        "method": "onWindowResize",
        "target": "window",
        "capture": false,
        "passive": true
      }];
  }
}
//# sourceMappingURL=system-notifications.js.map
