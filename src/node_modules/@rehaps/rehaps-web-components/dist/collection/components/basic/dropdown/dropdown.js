import { h, Host } from "@stencil/core";
import { EventManager } from "../../../utils/actions/eventManager";
export class RwcDropdown {
  constructor() {
    this.eventManager = new EventManager();
    this.openMode = 'manual';
    this.position = 'bottom';
    this.size = 'parent';
    this.mode = 'fixed';
    this.isOpen = false;
  }
  componentWillLoad() {
    this.parent = this.host.parentElement;
    this.init();
  }
  componentDidLoad() {
    this.wrapperElement.style.height = `0px`;
  }
  disconnectedCallback() {
    this.eventManager.clearEventListeners();
  }
  async init() {
    this.eventManager.clearEventListeners();
    this.initHoverEvents();
    this.initClickEvents();
  }
  onWindowScroll() {
    if (this.mode === 'fixed') {
      this.calculateDropdownOffset();
    }
  }
  onWindowResize() {
    if (this.isOpen) {
      this.setState(false);
    }
  }
  async onDocumentClick(event) {
    if (this.isOpen && !event.composedPath().includes(this.wrapperElement)) {
      await new Promise(requestAnimationFrame);
      this.setState(false);
    }
  }
  initHoverEvents() {
    if (this.openMode === 'hover') {
      this.eventManager.registerEventListener(this.parent, 'mouseenter', () => this.setState(true));
      this.eventManager.registerEventListener(this.parent, 'mouseleave', () => this.setState(false));
    }
  }
  initClickEvents() {
    if (this.openMode === 'toggle') {
      this.eventManager.registerEventListener(this.parent, 'click', async () => {
        if (!this.isOpen) {
          await new Promise(requestAnimationFrame);
          this.setState(true);
        }
      });
    }
  }
  async setState(value) {
    this.handleStateChange(value);
  }
  async handleStateChange(value) {
    this.isOpen = value;
    if (this.isOpen) {
      this.dropdownOpenEvent.emit();
    }
    else {
      this.dropdownCloseEvent.emit();
    }
    await new Promise(requestAnimationFrame);
    this.calculateDropdownSize();
    this.calculateDropdownOffset();
  }
  async calculateDropdownOffset() {
    if (this.wrapperElement && this.parent) {
      let offset = this.getStartingOffset();
      offset = this.calculateSideOffset(offset);
      offset = this.fixOverflow(offset);
      this.wrapperElement.style.left = this.isOpen ? `${offset.x}px` : '';
      this.wrapperElement.style.top = `${offset.y}px`;
    }
  }
  getStartingOffset() {
    if (this.mode === 'fixed') {
      return {
        x: this.parent.getBoundingClientRect().left,
        y: this.parent.getBoundingClientRect().top
      };
    }
    else {
      return {
        x: 0,
        y: 0
      };
    }
  }
  calculateSideOffset({ x, y }) {
    if (this.position === 'side') {
      x += this.parent.offsetWidth;
      if (this.mode === 'absolute') {
        y = -this.parent.offsetHeight;
      }
    }
    else if (this.mode === 'fixed') {
      y += this.parent.offsetHeight;
    }
    return {
      x: x,
      y: y
    };
  }
  fixOverflow({ x, y }) {
    const rightEdgePosition = this.mode === 'absolute' ?
      this.parent.getBoundingClientRect().left + x + this.wrapperElement.offsetWidth :
      x + this.wrapperElement.offsetWidth;
    if (rightEdgePosition > window.innerWidth) {
      x -= rightEdgePosition - window.innerWidth;
    }
    return {
      x: x,
      y: y
    };
  }
  async calculateDropdownSize() {
    this.wrapperElement.style.height = `${this.isOpen ? this.containerElement.offsetHeight : 0}px`;
    if (this.mode === 'fixed' && this.size === 'parent') {
      this.wrapperElement.style.width = `${this.parent.offsetWidth}px`;
    }
    else {
      this.wrapperElement.style.width = '';
    }
  }
  render() {
    return (h(Host, null, h("div", { ref: (element) => this.wrapperElement = element, class: {
        wrapper: true,
        open: this.isOpen,
        [`mode-${this.mode}`]: true,
        [`size-${this.size}`]: true
      } }, h("div", { ref: (element) => this.containerElement = element, class: "container" }, h("div", { class: "content" }, h("slot", null))))));
  }
  static get is() { return "rwc-dropdown"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["./dropdown.scss"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["dropdown.css"]
    };
  }
  static get properties() {
    return {
      "openMode": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "DropdownOpenMode",
          "resolved": "\"hover\" | \"manual\" | \"toggle\"",
          "references": {
            "DropdownOpenMode": {
              "location": "import",
              "path": "../../../interfaces/components/basic/dropdown/dropdown",
              "id": "src/interfaces/components/basic/dropdown/dropdown.ts::DropdownOpenMode"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "The open mode of the dropdown."
        },
        "attribute": "open-mode",
        "reflect": true,
        "defaultValue": "'manual'"
      },
      "position": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "DropdownPosition",
          "resolved": "\"bottom\" | \"side\"",
          "references": {
            "DropdownPosition": {
              "location": "import",
              "path": "../../../interfaces/components/basic/dropdown/dropdown",
              "id": "src/interfaces/components/basic/dropdown/dropdown.ts::DropdownPosition"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "The position of the dropdown from the parent."
        },
        "attribute": "position",
        "reflect": true,
        "defaultValue": "'bottom'"
      },
      "size": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "DropdownSize",
          "resolved": "\"auto\" | \"parent\"",
          "references": {
            "DropdownSize": {
              "location": "import",
              "path": "../../../interfaces/components/basic/dropdown/dropdown",
              "id": "src/interfaces/components/basic/dropdown/dropdown.ts::DropdownSize"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "The sizing of the dropdown."
        },
        "attribute": "size",
        "reflect": true,
        "defaultValue": "'parent'"
      },
      "mode": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "DropdownMode",
          "resolved": "\"absolute\" | \"fixed\"",
          "references": {
            "DropdownMode": {
              "location": "import",
              "path": "../../../interfaces/components/basic/dropdown/dropdown",
              "id": "src/interfaces/components/basic/dropdown/dropdown.ts::DropdownMode"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Determines the rendering behaviour of the dropdown."
        },
        "attribute": "mode",
        "reflect": true,
        "defaultValue": "'fixed'"
      }
    };
  }
  static get states() {
    return {
      "isOpen": {}
    };
  }
  static get events() {
    return [{
        "method": "dropdownOpenEvent",
        "name": "dropdownOpen",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Event fired when the dropdown opening is triggered."
        },
        "complexType": {
          "original": "void",
          "resolved": "void",
          "references": {}
        }
      }, {
        "method": "dropdownCloseEvent",
        "name": "dropdownClose",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Event fired when the dropdown closing is triggered"
        },
        "complexType": {
          "original": "void",
          "resolved": "void",
          "references": {}
        }
      }];
  }
  static get methods() {
    return {
      "init": {
        "complexType": {
          "signature": "() => Promise<void>",
          "parameters": [],
          "references": {
            "Promise": {
              "location": "global",
              "id": "global::Promise"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "Initialize the component.",
          "tags": []
        }
      },
      "setState": {
        "complexType": {
          "signature": "(value: boolean) => Promise<void>",
          "parameters": [{
              "tags": [],
              "text": ""
            }],
          "references": {
            "Promise": {
              "location": "global",
              "id": "global::Promise"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "Set state of the dropdown.",
          "tags": []
        }
      }
    };
  }
  static get elementRef() { return "host"; }
  static get listeners() {
    return [{
        "name": "scroll",
        "method": "onWindowScroll",
        "target": "window",
        "capture": false,
        "passive": true
      }, {
        "name": "resize",
        "method": "onWindowResize",
        "target": "window",
        "capture": false,
        "passive": true
      }, {
        "name": "click",
        "method": "onDocumentClick",
        "target": "document",
        "capture": false,
        "passive": false
      }];
  }
}
//# sourceMappingURL=dropdown.js.map
